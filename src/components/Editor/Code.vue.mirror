<template>
  <div class="full-height">
    <textarea ref="EditorCode" />
  </div>
</template>

<script lang="ts">
// eslint-disable-next-line import/order
import { defineComponent, ref } from "vue";
import CodeMirror from "codemirror";
// eslint-disable-next-line import/order
import { extname } from "path-cross";
import "codemirror/lib/codemirror.css";

import "codemirror/mode/meta";

import "codemirror/addon/mode/loadmode";

import "codemirror/addon/hint/show-hint.css";
import "codemirror/addon/hint/show-hint.js";
import "codemirror/addon/hint/anyword-hint.js";

import "codemirror/addon/lint/lint.css";
import "codemirror/addon/lint/lint.js";

import "codemirror/addon/selection/active-line.js";
import "codemirror/addon/selection/selection-pointer.js";

import "codemirror/addon/edit/closetag.js";
import "codemirror/addon/edit/matchbrackets.js";
import "codemirror/addon/edit/closebrackets.js";

import "codemirror/addon/fold/foldgutter.css";
import "codemirror/addon/fold/brace-fold.js";
import "codemirror/addon/fold/comment-fold.js";
import "codemirror/addon/fold/foldcode.js";
import "codemirror/addon/fold/foldgutter.js";
import "codemirror/addon/fold/indent-fold.js";
import "codemirror/addon/fold/markdown-fold.js";
import "codemirror/addon/fold/xml-fold.js";

// import "codemirror/mode/javascript/javascript.js";
import fs from "src/modules/fs";
import { createTimeoutBy } from "src/utils";

// eslint-disable-next-line @typescript-eslint/no-explicit-any, functional/immutable-data
(self as any).CodeMirror = "../../mode/%N/%N.js";

export default defineComponent({
  name: "Editor-Code",
  props: {
    fullpath: {
      type: String,
      required: true,
    },
  },
  setup() {
    const EditorCode = ref<HTMLTextAreaElement | null>(null);
    const editor: {
      value: CodeMirror.EditorFromTextArea | null;
    } = {
      value: null,
    };

    return {
      EditorCode,
      editor,
    };
  },
  methods: {
    async loadFile(path: string): Promise<void> {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      this.editor.value?.off("change", this.onChange);
      // eslint-disable-next-line @typescript-eslint/unbound-method, @typescript-eslint/no-misused-promises
      this.editor.value?.off("scroll", this.onScroll);

      const { mime = "application/text", mode = "text" } =
        CodeMirror.findModeByExtension(extname(path).replace(/^\./, "")) || {};

      if (!CodeMirror.modes.hasOwnProperty(mode)) {
        require(`codemirror/mode/${mode}/${mode}.js`);
      }

      try {
        this.editor.value?.setValue(await fs.readFile(path, "utf8"));
        void this.restoreScrollBehavior(path);
      } catch {}

      this.editor.value?.setOption("mode", mime);

      // eslint-disable-next-line @typescript-eslint/unbound-method
      this.editor.value?.on("change", this.onChange);
      // eslint-disable-next-line @typescript-eslint/unbound-method, @typescript-eslint/no-misused-promises
      this.editor.value?.on("scroll", this.onScroll);
    },
    onChange() {
      // change file
      createTimeoutBy(
        "auto save",
        async () => {
          if (this.editor.value) {
            await fs.writeFile(this.fullpath, this.editor.value.getValue());
          }
        },
        1000
      );
    },
    // eslint-disable-next-line @typescript-eslint/require-await
    async onScroll() {
      console.log("scroll");
    },
    saveScrollBehavior(fullpath: string): void {
      console.log("save", fullpath);
    },
    restoreScrollBehavior(fullpath: string): void {
      console.log("save", fullpath);
    },
    "set:theme"(name: CodeMirror.EditorConfiguration["theme"]): void {
      require(`codemirror/theme/${name + ""}.css`);

      this.editor.value?.setOption("theme", name);
    },
  },

  mounted() {
    // eslint-disable-next-line functional/immutable-data
    this.editor.value = CodeMirror.fromTextArea(
      this.EditorCode as HTMLTextAreaElement,
      {
        lineNumbers: true,
        // value: "function myScript(){return 100;}\n",
        // mode: "javascript",
        mode: "text/typescript",
        theme: "3024-night",
        lineWrapping: true,

        // styleActiveLine: true,
        autoCloseTags: true,
        foldGutter: true,
        dragDrop: true,
        matchBrackets: true,
        lint: {
          esversion: "8",
          unused: true,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } as any,

        // lintFix: {
        //   getFixes: () => {},
        // },
        extraKeys: {
          "Ctrl-Space": "autocomplete",
        },
        // autohint: true,
        gutters: [
          "CodeMirror-lint-markers",
          "CodeMirror-linenumbers",
          "CodeMirror-foldgutter",
        ],
        // styleSelectedText: true,
        selectionPointer: true,
        // styleActiveLine: true,
        autoCloseBrackets: true,
      }
    );

    /// for hint
    this.editor.value.on("optionChange", (_instance, opt) => {
      if (opt === "mode") {
        const mime = this.editor.value?.getOption("mode");
        // eslint-disable-next-line functional/no-let
        let mode = mime
          ? CodeMirror.findModeByMIME(mime as string)?.mode
          : null ?? mime;

        try {
          if (mode === "htmlmixed") {
            mode = "html";
          }
          require(`codemirror/addon/hint/${mode as string}-hint.js`);
        } catch {
          console.warn(`show-hint: can't load ${mode as string}`);
        }
      }
    });
    /// for lint
    this.editor.value.on("optionChange", (_instance, opt) => {
      if (opt === "mode") {
        const mime = this.editor.value?.getOption("mode");
        // eslint-disable-next-line functional/no-let
        let mode = mime
          ? CodeMirror.findModeByMIME(mime as string)?.mode
          : null ?? mime;

        try {
          if (mode === "htmlmixed") {
            mode = "html";
          }

          if (mime === "application/typescript") {
            this.editor.value?.setOption("lint", false);
            return;
          }

          this.editor.value?.setOption("lint", {
            esversion: "8",
            unused: true,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          } as any);

          if (mode === "javascript" && mime !== "application/typescript") {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-var-requires, functional/immutable-data
            (window as any).JSHINT = require("jshint/dist/jshint.js").JSHINT;
          }
          if (mode === "json") {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any,
            if (!(window as any).jsonlint) {
              const code =
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                require("!raw-loader!jsonlint/web/jsonlint.js").default +
                ";window.jsonlint=jsonlint;";
              eval(code);
            }
          }
          if (mode === "css") {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (!(window as any).CSSLint) {
              const code =
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                require("!raw-loader!csslint/dist/csslint.js").default +
                ";window.CSSLint=CSSLint;";
              eval(code);
            }
          }
          require(`codemirror/addon/lint/${mode as string}-lint.js`);
        } catch (e) {
          console.error(e);
          console.warn(`show-lint: can't load ${mode as string}`);
        }
      }
    });

    this.editor.value.on("keypress", () => {
      this.editor.value?.execCommand("autocomplete");
    });

    this.editor.value.setSize("100%", "100%");
    this["set:theme"]("3024-night");

    this.$watch(
      "fullpath",
      (newPath: string) => {
        void this.loadFile(newPath);
      },
      {
        immediate: true,
      }
    );
  },
});
</script>
